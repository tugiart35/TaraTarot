#!/usr/bin/env node

/**
 * Smart Translation Analyzer
 *
 * Bu script:
 * 1. tr.json'daki T√úM anahtarlarƒ± √ßƒ±karƒ±r
 * 2. Kodda GER√áEKTEN kullanƒ±lan anahtarlarƒ± bulur
 * 3. Kategorilere ayƒ±rƒ±r
 * 4. Manuel inceleme i√ßin rapor olu≈üturur
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// T√ºm anahtarlarƒ± d√ºz liste olarak √ßƒ±kar
function flattenKeys(obj, prefix = '', result = {}) {
  for (const key in obj) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    const value = obj[key];

    if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
      flattenKeys(value, fullKey, result);
    } else {
      result[fullKey] = value;
    }
  }
  return result;
}

// Kodda anahtar kullanƒ±mƒ±nƒ± kontrol et
function isKeyUsedInCode(key, srcDir) {
  try {
    // Farklƒ± kullanƒ±m pattern'leri
    const patterns = [
      // t('full.key.path')
      `t\\(['"\`]${key.replace(/\./g, '\\.')}['"\`]`,
      // Sadece key string olarak
      `['"\`]${key.replace(/\./g, '\\.')}['"\`]`,
    ];

    // Parent key kontrol√º (nested yapƒ±lar i√ßin)
    const keyParts = key.split('.');
    if (keyParts.length > 1) {
      // ƒ∞lk seviye kontrol√º
      patterns.push(`t\\(['"\`]${keyParts[0]}['"\`]`);
      // ƒ∞kinci seviye kontrol√º
      if (keyParts.length > 2) {
        patterns.push(`t\\(['"\`]${keyParts[0]}\\.${keyParts[1]}['"\`]`);
      }
    }

    for (const pattern of patterns) {
      try {
        // ripgrep ile ara
        const cmd = `rg -q "${pattern}" ${srcDir} --type ts --type tsx --type js --type jsx 2>/dev/null`;
        execSync(cmd, { stdio: 'pipe' });
        return true; // Bulundu
      } catch (e) {
        // Bulunamadƒ±, devam et
      }
    }

    return false;
  } catch (error) {
    return false;
  }
}

// Deƒüer benzerliƒüini kontrol et
function findSimilarValues(allKeys) {
  const valueToKeys = new Map();

  Object.entries(allKeys).forEach(([key, value]) => {
    if (typeof value === 'string' && value.trim().length > 3) {
      const normalized = value.toLowerCase().trim();

      if (!valueToKeys.has(normalized)) {
        valueToKeys.set(normalized, []);
      }
      valueToKeys.get(normalized).push({ key, value });
    }
  });

  const duplicates = [];
  valueToKeys.forEach((keys, normalizedValue) => {
    if (keys.length > 1) {
      duplicates.push({
        value: keys[0].value,
        count: keys.length,
        keys: keys.map(k => k.key),
      });
    }
  });

  // En √ßok tekrar edenlere g√∂re sƒ±rala
  duplicates.sort((a, b) => b.count - a.count);

  return duplicates;
}

// Ana analiz
async function smartAnalyze() {
  log('\nüîç AKILLI Translation Analizi Ba≈ülƒ±yor...', 'cyan');
  log('‚ïê'.repeat(70), 'cyan');

  const trJsonPath = path.join(__dirname, 'messages', 'tr.json');
  const srcDir = path.join(__dirname, 'src');

  // tr.json'ƒ± y√ºkle
  log('\nüìñ tr.json dosyasƒ± okunuyor...', 'blue');
  const trData = JSON.parse(fs.readFileSync(trJsonPath, 'utf-8'));
  const allKeys = flattenKeys(trData);
  const totalKeys = Object.keys(allKeys).length;

  log(`‚úÖ ${totalKeys} anahtar bulundu`, 'green');

  // Kategorilere ayƒ±r
  const categories = {
    used: [],
    unused: [],
    probablyUsed: [], // Parent key kullanƒ±lƒ±yorsa
    empty: [],
    suspicious: [], // Bo≈ü, "TODO", vb.
  };

  log('\nüîç Anahtarlar analiz ediliyor...', 'yellow');
  log('‚è≥ Bu i≈ülem 3-5 dakika s√ºrebilir...\n', 'yellow');

  let processed = 0;
  const keys = Object.keys(allKeys);

  for (const key of keys) {
    processed++;
    if (processed % 50 === 0) {
      const percent = Math.round((processed / totalKeys) * 100);
      process.stdout.write(
        `\r‚è≥ ƒ∞lerleme: ${processed}/${totalKeys} (${percent}%)   `
      );
    }

    const value = allKeys[key];

    // Bo≈ü veya ≈ü√ºpheli deƒüerleri kategorize et
    if (
      !value ||
      value === '' ||
      value === 'TODO' ||
      value === 'N/A' ||
      value === 'bo≈ü' ||
      value === '-'
    ) {
      categories.empty.push({ key, value, reason: 'Bo≈ü veya placeholder' });
      continue;
    }

    // Kodda kullanƒ±mƒ± kontrol et
    const isUsed = isKeyUsedInCode(key, srcDir);

    if (isUsed) {
      categories.used.push({ key, value });
    } else {
      // Parent key kontrol√º
      const keyParts = key.split('.');
      if (keyParts.length > 1) {
        const parentKey = keyParts.slice(0, -1).join('.');
        const isParentUsed = isKeyUsedInCode(parentKey, srcDir);

        if (isParentUsed) {
          categories.probablyUsed.push({
            key,
            value,
            reason: `Parent key "${parentKey}" kullanƒ±lƒ±yor`,
          });
        } else {
          categories.unused.push({ key, value });
        }
      } else {
        categories.unused.push({ key, value });
      }
    }
  }

  console.log(''); // Yeni satƒ±r

  // Tekrar edenleri bul
  log('\nüîç Tekrar eden deƒüerler aranƒ±yor...', 'yellow');
  const duplicates = findSimilarValues(allKeys);
  log(`‚úÖ ${duplicates.length} tekrar eden deƒüer bulundu`, 'green');

  // Sonu√ßlarƒ± g√∂ster
  log('\n' + '‚ïê'.repeat(70), 'cyan');
  log('üìä ANALƒ∞Z SONU√áLARI', 'bright');
  log('‚ïê'.repeat(70), 'cyan');

  log(
    `\n‚úÖ Kullanƒ±lan:              ${categories.used.length} (${((categories.used.length / totalKeys) * 100).toFixed(1)}%)`,
    'green'
  );
  log(
    `üü° Muhtemelen Kullanƒ±lan:   ${categories.probablyUsed.length} (${((categories.probablyUsed.length / totalKeys) * 100).toFixed(1)}%)`,
    'yellow'
  );
  log(
    `‚ùå Kullanƒ±lmayan:           ${categories.unused.length} (${((categories.unused.length / totalKeys) * 100).toFixed(1)}%)`,
    'red'
  );
  log(`‚ö™ Bo≈ü/≈û√ºpheli:             ${categories.empty.length}`, 'magenta');
  log(`üîÑ Tekrar Eden Deƒüer:       ${duplicates.length}`, 'yellow');

  // Detaylƒ± rapor olu≈ütur
  const report = {
    metadata: {
      analyzedFile: 'messages/tr.json',
      totalKeys: totalKeys,
      analysisDate: new Date().toISOString(),
      srcDirectory: 'src/',
    },
    summary: {
      used: categories.used.length,
      probablyUsed: categories.probablyUsed.length,
      unused: categories.unused.length,
      empty: categories.empty.length,
      duplicates: duplicates.length,
    },
    statistics: {
      usageRate: ((categories.used.length / totalKeys) * 100).toFixed(2) + '%',
      unusageRate:
        ((categories.unused.length / totalKeys) * 100).toFixed(2) + '%',
      potentialSavings: `${categories.unused.length + categories.empty.length} anahtar`,
    },
    categories: {
      used: categories.used.slice(0, 100), // ƒ∞lk 100
      probablyUsed: categories.probablyUsed,
      unused: categories.unused,
      empty: categories.empty,
    },
    duplicates: duplicates,
    recommendations: [],
  };

  // √ñneriler olu≈ütur
  if (categories.empty.length > 0) {
    report.recommendations.push({
      priority: 'HIGH',
      action: 'DELETE',
      count: categories.empty.length,
      description: `${categories.empty.length} bo≈ü/placeholder deƒüer hemen silinebilir`,
      keys: categories.empty.map(k => k.key),
    });
  }

  if (categories.unused.length > 500) {
    report.recommendations.push({
      priority: 'MEDIUM',
      action: 'REVIEW_AND_DELETE',
      count: categories.unused.length,
      description: `${categories.unused.length} kullanƒ±lmayan anahtar var. Batch halinde temizlenebilir.`,
      suggestion: 'ƒ∞lk 100 anahtarla ba≈ülayƒ±n, test edin, sonra devam edin',
    });
  }

  if (duplicates.length > 50) {
    report.recommendations.push({
      priority: 'LOW',
      action: 'CONSOLIDATE',
      count: duplicates.length,
      description: `${duplicates.length} tekrar eden deƒüer var. Bunlar birle≈ütirilebilir.`,
      suggestion:
        '√ñnce kullanƒ±lmayanlarƒ± temizleyin, sonra duplicatelere bakƒ±n',
    });
  }

  // Raporlarƒ± kaydet
  const jsonReportPath = path.join(__dirname, 'smart-analysis-report.json');
  fs.writeFileSync(jsonReportPath, JSON.stringify(report, null, 2));

  // Okunabilir rapor
  const txtReportPath = path.join(__dirname, 'smart-analysis-report.txt');
  let txtReport = '';

  txtReport += '‚ïê'.repeat(80) + '\n';
  txtReport += '              üîç AKILLI TRANSLATION ANALƒ∞Z RAPORU\n';
  txtReport += '‚ïê'.repeat(80) + '\n\n';

  txtReport += 'üìä √ñZET\n';
  txtReport += '‚îÄ'.repeat(80) + '\n';
  txtReport += `Toplam Anahtar:           ${totalKeys}\n`;
  txtReport += `‚úÖ Kullanƒ±lan:             ${categories.used.length} (${report.statistics.usageRate})\n`;
  txtReport += `üü° Muhtemelen Kullanƒ±lan:  ${categories.probablyUsed.length}\n`;
  txtReport += `‚ùå Kullanƒ±lmayan:          ${categories.unused.length} (${report.statistics.unusageRate})\n`;
  txtReport += `‚ö™ Bo≈ü/≈û√ºpheli:            ${categories.empty.length}\n`;
  txtReport += `üîÑ Tekrar Eden Deƒüer:      ${duplicates.length}\n`;
  txtReport += `Analiz Tarihi:            ${new Date().toLocaleString('tr-TR')}\n\n`;

  // Bo≈ü deƒüerler
  if (categories.empty.length > 0) {
    txtReport += '\n‚ö™ BO≈û/≈û√úPHELƒ∞ DEƒûERLER (HEPSƒ∞)\n';
    txtReport += '‚îÄ'.repeat(80) + '\n';
    txtReport += '‚ùó √ñNCELƒ∞K: Y√úKSEK - Bunlar hemen silinebilir\n\n';

    categories.empty.forEach(({ key, value, reason }) => {
      txtReport += `‚Ä¢ ${key}\n`;
      txtReport += `  Deƒüer: "${value}"\n`;
      txtReport += `  Sebep: ${reason}\n\n`;
    });
  }

  // Kullanƒ±lmayan anahtarlar - kategorilere ayrƒ±lmƒ±≈ü
  if (categories.unused.length > 0) {
    txtReport += '\n‚ùå KULLANILMAYAN ANAHTARLAR\n';
    txtReport += '‚îÄ'.repeat(80) + '\n';
    txtReport += `Toplam: ${categories.unused.length} anahtar\n`;
    txtReport += '‚ùó √ñNCELƒ∞K: ORTA - Manuel kontrol sonrasƒ± silinebilir\n\n';

    // Kategorilere g√∂re grupla
    const grouped = {};
    categories.unused.forEach(({ key, value }) => {
      const topLevel = key.split('.')[0];
      if (!grouped[topLevel]) {
        grouped[topLevel] = [];
      }
      grouped[topLevel].push({ key, value });
    });

    // Her kategoriyi g√∂ster
    Object.keys(grouped)
      .sort()
      .forEach(category => {
        txtReport += `\nüìÅ ${category.toUpperCase()} Kategorisi (${grouped[category].length} anahtar)\n`;
        txtReport += '‚îÄ'.repeat(40) + '\n';

        grouped[category].slice(0, 20).forEach(({ key, value }) => {
          const preview =
            typeof value === 'string' && value.length > 60
              ? value.substring(0, 60) + '...'
              : value;
          txtReport += `  ‚Ä¢ ${key}\n    "${preview}"\n`;
        });

        if (grouped[category].length > 20) {
          txtReport += `  ... ve ${grouped[category].length - 20} anahtar daha\n`;
        }
        txtReport += '\n';
      });
  }

  // Muhtemelen kullanƒ±lanlar
  if (categories.probablyUsed.length > 0) {
    txtReport += '\nüü° MUHTEMELEN KULLANILAN ANAHTARLAR\n';
    txtReport += '‚îÄ'.repeat(80) + '\n';
    txtReport += `Toplam: ${categories.probablyUsed.length} anahtar\n`;
    txtReport +=
      '‚ùó Dƒ∞KKAT: Parent key kullanƒ±lƒ±yor, bu anahtarlar dinamik olabilir\n\n';

    categories.probablyUsed.slice(0, 30).forEach(({ key, value, reason }) => {
      txtReport += `‚Ä¢ ${key}\n`;
      txtReport += `  "${value}"\n`;
      txtReport += `  ${reason}\n\n`;
    });

    if (categories.probablyUsed.length > 30) {
      txtReport += `... ve ${categories.probablyUsed.length - 30} anahtar daha\n\n`;
    }
  }

  // Tekrar eden deƒüerler
  if (duplicates.length > 0) {
    txtReport += '\nüîÑ TEKRAR EDEN DEƒûERLER (En √áok Tekrar Edenler)\n';
    txtReport += '‚îÄ'.repeat(80) + '\n';
    txtReport += `Toplam: ${duplicates.length} tekrar eden deƒüer\n`;
    txtReport += '‚ùó √ñNCELƒ∞K: D√ú≈û√úK - Birle≈ütirilebilir ama acil deƒüil\n\n';

    duplicates.slice(0, 30).forEach(({ value, count, keys }) => {
      const preview =
        value.length > 70 ? value.substring(0, 70) + '...' : value;
      txtReport += `"${preview}"\n`;
      txtReport += `${count} yerde kullanƒ±lƒ±yor:\n`;
      keys.slice(0, 5).forEach(key => {
        txtReport += `  ‚Ä¢ ${key}\n`;
      });
      if (keys.length > 5) {
        txtReport += `  ... ve ${keys.length - 5} anahtar daha\n`;
      }
      txtReport += '\n';
    });
  }

  // √ñneriler
  txtReport += '\n' + '‚ïê'.repeat(80) + '\n';
  txtReport += 'üí° √ñNERƒ∞LER VE EYLEM PLANI\n';
  txtReport += '‚ïê'.repeat(80) + '\n\n';

  if (categories.empty.length > 0) {
    txtReport += `1Ô∏è‚É£ Y√úKSEK √ñNCELƒ∞K: ${categories.empty.length} bo≈ü deƒüeri hemen silin\n`;
    txtReport += '   Komut: node safe-clean-translations.js (Se√ßenek 1)\n\n';
  }

  if (categories.unused.length > 0) {
    txtReport += `2Ô∏è‚É£ ORTA √ñNCELƒ∞K: ${categories.unused.length} kullanƒ±lmayan anahtarƒ± temizleyin\n`;
    txtReport += '   √ñnerilen Strateji:\n';
    txtReport += '   ‚Ä¢ Adƒ±m 1: ƒ∞lk 100 anahtarƒ± sil ‚Üí Test et\n';
    txtReport += '   ‚Ä¢ Adƒ±m 2: Sonraki 500 anahtarƒ± sil ‚Üí Test et\n';
    txtReport += '   ‚Ä¢ Adƒ±m 3: Kalanlarƒ± sil ‚Üí Test et\n\n';
  }

  if (categories.probablyUsed.length > 0) {
    txtReport += `3Ô∏è‚É£ Dƒ∞KKAT: ${categories.probablyUsed.length} anahtar dinamik kullanƒ±m olabilir\n`;
    txtReport += '   Bu anahtarlarƒ± manuel kontrol edin\n\n';
  }

  if (duplicates.length > 50) {
    txtReport += `4Ô∏è‚É£ D√ú≈û√úK √ñNCELƒ∞K: ${duplicates.length} tekrar eden deƒüer\n`;
    txtReport +=
      '   √ñnce kullanƒ±lmayanlarƒ± temizleyin, sonra bunlara d√∂n√ºn\n\n';
  }

  const estimatedSavings =
    ((categories.unused.length + categories.empty.length) / totalKeys) * 100;
  txtReport += `üíæ Potansiyel Tasarruf: ~${estimatedSavings.toFixed(1)}% (${categories.unused.length + categories.empty.length} anahtar)\n`;

  txtReport += '\n' + '‚ïê'.repeat(80) + '\n';
  txtReport += `Rapor Tarihi: ${new Date().toLocaleString('tr-TR')}\n`;
  txtReport += '‚ïê'.repeat(80) + '\n';

  fs.writeFileSync(txtReportPath, txtReport);

  log('‚úÖ Analiz tamamlandƒ±!\n', 'green');
  log('üìÑ Raporlar:', 'cyan');
  log(`   ‚Ä¢ ${path.basename(jsonReportPath)} (Detaylƒ± JSON)`, 'blue');
  log(`   ‚Ä¢ ${path.basename(txtReportPath)} (Okunabilir)`, 'blue');

  log('\nüí° Sonraki Adƒ±m:', 'cyan');
  log(`   cat ${path.basename(txtReportPath)} | less`, 'yellow');
  log('   Raporu inceleyin ve temizleme stratejisi belirleyin\n', 'yellow');
}

// √áalƒ±≈ütƒ±r
smartAnalyze().catch(error => {
  log('\n‚ùå Hata:', 'red');
  console.error(error);
  process.exit(1);
});
